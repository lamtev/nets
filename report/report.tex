\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\listoffigures
\listoftables
\newpage

\section{Задание}

\subsection{Формулировка}

Разработать приложение-сервер <<Удаленный калькулятор>>, позволяющее по запросу выполнять математические операции, и удаленный клиент для сервера.

\subsection{Основные возможности}

Серверное приложение должно реализовывать следующие функции:

\begin{enumerate}
	\item Прослушивание определенного порта
	\item Обработка запросов на подключение по этому порту от клиентов
	\item Поддержка одновременной работы нескольких клиентов через механизм нитей
	\item Приём <<быстрых>> операций с аргументами от клиента. Должны поддерживаться следующие операции: сложение, вычитание, умножение,
деление
	\item Вычисление <<долгих>> математических операций (факториал, квадратный корень) с последующей отложенной посылкой результата клиенту (отдельная операция, инициируемая сервером).
	\item Обработка запроса на отключение клиента
	\item Принудительное отключение клиента
\end{enumerate}

Клиентское приложение должно реализовывать следующие функции:

\begin{enumerate}
	\item Установление соединения с сервером
	\item Посылка операции с аргументами на вычисление
	\item Получение результата вычислений <<быстрых>> операций
	\item Получения результата вычислений <<долгих>> операций
	\item Разрыв соединения
	\item  Обработка ситуации отключения клиента сервером
\end{enumerate}

\subsection{Настройки приложений}

Разработанное клиентское приложение должно предоставлять пользователю настройку IP-адреса или доменного имени удалённого калькулятора и номера порта, используемого сервером. Разработанное серверное приложение должно предоставлять пользователю настройку времени выполнения <<долгих>> операций. 

\subsection{Методика тестирования}

Для тестирования приложений запускается сервер <<Удаленного калькулятора>> и несколько клиентов. В процессе тестирования проверяются основные возможности калькулятора по мгновенному и отложенному выполнению удалённых операций. 

\section{Прикладной протокол}
%Описание форматов команд и ответов (например, в табличном виде: набор и формат команд, размеры полей, сообщения об ошибках). Прикладной протокол не зависит от нижележащего транспортного протокола, а также от языка и технологии программирования.

Разработанный протокол является бинарным, формат сообщения представлен на рис. \ref{fig:calc-prot}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{CalculatorProtocol}
	\caption{Формат сообщения}
	\label{fig:calc-prot}
\end{figure}

Сообщение разделено на 3 блока:

\begin{enumerate}
	\item Содержит размер следующих блоков в байтах ($N$). Занимает 1 байт
	\item Содержит тип сообщения, который занимает 1 байт
	\item Содержит данные, которые занимают $N-1$ байтов 
\end{enumerate}

В таблице \ref{tab:msg-types} представлены возможные типы сообщений и их бинарное представление.

\begin{table}[H]
\begin{center}
	\caption{Типы сообщений}
	\label{tab:msg-types}
	\def\tabcolsep{10pt}
	\def\arraystretch{1.23}
	\begin{tabular}{|c|c|c|}
		\hline 
		& Тип сообщения & Бинарное представление \\ 
		\hline 
		1 & Математический запрос & $0000\text{ }0000$ \\ 
		\hline 
		2 & Ответ на математический запрос & $0000\text{ }0001$ \\ 
		\hline 
		3 & Управляющий запрос & $0000\text{ }0010$ \\ 
		\hline 
		4 & Ответ на управляющий запрос & $0000\text{ }0011$ \\ 
		\hline 
	\end{tabular} 
\end{center}
\end{table}

Ниже представлен формат данных для каждого типа сообщения:

\begin{enumerate}
	\item \textbf{Математический запрос}.
	
	Формат данных приведен на рис. \ref{fig:math-req}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth]{MathOperation}
		\caption{Формат данных математического запроса}
		\label{fig:math-req}
	\end{figure}
	
	Данные разделены на 2 блока: тип операции, который занимает 1 байт, и данные (аргументы), которые занимают 8 байтов, если для данного типа операции необходим 1 операнд, или 16 байтов, если -- 2 операнда.
	
	В таблице \ref{tab:msg-types} представлены возможные типы операций, их бинарное представление и соответствующее количество аргументов.

	Операнды в бинарном виде кодируются <<старшими байтами вперёд>>.

	\begin{table}[H]
	\begin{center}
		\caption{Типы операций}
		\label{tab:msg-types}
		\def\tabcolsep{4pt}
		\begin{tabular}{|c|c|c|c|}
			\hline 
			& Тип операции & Бинарное представление & Число операндов \\ 
			\hline 
			1 & Сложение & $0000\text{ }0000$ & 2\\ 
			\hline 
			2 & Вычитание & $0000\text{ }0001$ & 2\\ 
			\hline 
			3 & Умножение & $0000\text{ }0010$ & 2\\ 
			\hline 
			4 & Деление & $0000\text{ }0011$ & 2\\ 
			\hline
			5 & Квадратный корень & $0000\text{ }0100$ & 1\\ 
			\hline 
			6 & Факториал & $0000\text{ }0101$  & 1\\ 
			\hline 
		\end{tabular} 
	\end{center}
	\end{table}
	
	\item \textbf{Ответ на математический запрос}.
	
	Данные для этого типа сообщения состоят из 2-х блоков: типа ответа, который кодируется 1 байтом, и численным результатом, который кодируется 8 байтами. Типы ответов, их бинарное представление и соответствующие значения численного результата приведены в таблице \ref{tab:math-resp}.
	
	\begin{table}[H]
	\begin{center}
		\caption{Типы ответов на математический запрос}
		\label{tab:math-resp}
		\def\tabcolsep{4pt}
		\fontsize{10}{11}\selectfont
		\begin{tabular}{|c|c|c|c|}
			\hline 
			& Тип ответа & Бинарное представление & Численный результат \\ 
			\hline 
			1 & Неправильная операция & $0000\text{ }0000$ & $0000\text{ }0000$\\ 
			\hline 
			2 & Результат на быструю операцию & $0000\text{ }0001$ & Вычисленное значение\\ 
			\hline 
			3 & <<Долгая>> операция была принята к вычислению & $0000\text{ }0010$ & $0000\text{ }0000$\\ 
			\hline 
		\end{tabular} 
	\end{center}
	\end{table}	

	2-й блок, в котором находится результат, заполняется 8-байтным числом-результатом матемаической операции, если тип ответа равен результату на быструю операцию, в остальных случаях заполняется нулём.	
	
		\item \textbf{Управляющий запрос запрос}.
		
		Данные для этого типа сообщения состоят из одного блока -- кода управляющего запроса, который кодируется 1 байтом. В настоящее время поддерживается 1 управляющий запрос -- запрос клиента на отключение себя. Ему соответствует код $0000\text{ }0000$.
	
		\item \textbf{Ответ на управляющий запрос запрос}.
		
		Данные для этого типа сообщения состоят из 1 блока -- кода ответа, который кодируется 1 байтом. В настоящее время ответ всегда 1 -- запрос на отключение прошёл успешно. Ему соответствует код $0000\text{ }0000$.
	
\end{enumerate}

\section{Описание архитектур приложений на основе \code{TCP} и \code{UDP}}
%приложений на основе TCP и UDP, их особенностей и ограничений (с графическими схемами

\subsection{Приложение на основе \code{TCP}}\label{sec:arch:tcp}

Архитектура приложения изображена на UML диаграмме компонентов на рис. \ref{fig:tcp-comp}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{TCPComponents}
	\caption{UML-диаграмма компонентов \code{TCP} приложения}
	\label{fig:tcp-comp}
\end{figure}

UML-диаграмма классов серверной части приложения представлена на рис. \ref{fig:tcp-classes}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{TCPClasses}
	\caption{UML-диаграмма классов \code{TCP} сервера}
	\label{fig:tcp-classes}
\end{figure}

Класс \code{TCPServer} включает в себя два других --- \code{ServerIO} и \code{TCPServerNet}. \code{ServerIO} осуществляет взаимодействие с администратором через терминал, а также печатает в него возникающие ошибки.  В классе \code{TCPServerNet} реализована сетевая часть. 

При помощи паттерна проектирования Делегат, классы \code{ServerIO} и \code{TCPServerNet} взаимодейтсвуют друг с другом, реализуя соответственно интерфейсы 

\code{ServerNetDelegate} и \code{ServerIODelegate}.

Когда в классе \code{TCPServerNet} произошла сетевая ошибка или событие, о котором следует напечатать в консоль, он вызывает соответствующий метод \code{netDidFailWithError(ServerNet net, ServerNetError error)} своего делегата, которым является \code{ServerIO}.

Когда администратору сервера требуется вывести список обслуживаемых сервером клиентов, отключить какого-либо клиента или вовсе завершить работу сервера, он пишет команду в терминал, которая сначала принимается классом \code{ServerIO}, который затем вызывает методы

\code{ioWantsToKillClientWithId(ServerIO io, uint64\_t id)},

\code{ioWantsToListClients(ServerIO io)} и 
 
\code{ioWantsToExit(ServerIO io)} своего делегата, которым является \code{TCPServerNet}.\\[3mm]

Сервер поддерживает следующие консольные команды:

\begin{enumerate}
	\item \code{list} --- вывести список всех обслуживаемых клиентов в формате:\\ \code{ID. IP:PORT}
	\item \code{kill <client\_id>} --- отключить клиента с ID, равным <client\_id>
	\item \code{exit} --- завершить работу сервера
\end{enumerate}

Архитектура клиентской части приложения проста, и весь исходный код поместился в 1 файл.

Клиент поддерживает следующие консольные команды:

\begin{enumerate}
	\item \code{<A>+<B>} --- сложить числа \code{<A>} и \code{<B>}
	\item \code{<A>-<B>} --- вычесть из числа \code{<A>} число \code{<B>}
	\item \code{<A>*<B>} --- перемножить числа \code{<A>} и \code{<B>}
	\item \code{<A>\textbackslash<B>} --- разделить число \code{<A>} на число \code{<B>}
	\item \code{v<A>} --- извлечь квадратный корень из числа \code{<A>}
	\item \code{<A>!} --- вычислить факториал числа \code{<A>}
	\item \code{kill me} --- запрос к серверу на отключение
\end{enumerate}

\subsection{Приложение на основе \code{UDP}}

Архитектура приложения изображена на UML диаграмме компонентов на рис. \ref{fig:udp-comp}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{UDPComponents}
	\caption{UML-диаграмма компонентов \code{UDP} приложения}
	\label{fig:udp-comp}
\end{figure}

UML-диаграмма классов серверной части приложения представлена на рис. \ref{fig:udp-classes}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{UDPClasses}
	\caption{UML-диаграмма классов \code{UDP} сервера}
	\label{fig:udp-classes}
\end{figure}

В результате проектирования приложения на основе \code{TCP} получилась удачная архитектура (раздел \ref{sec:arch:tcp}), которая позволила при реализации \code{UDP} сервера разработать лишь классы \code{UDPServer} и \code{UDPServerNet}, которые являются заменой классам \code{TCPServer} и \code{TCPServerNet}. Другие отличия в архитектуре закрыты в реализациях \code{ServerNet} и будут рассмотрены в разделе \ref{sec:net}.\\[3mm]

Исходный код клиентской части \code{UDP} приложения состоит из одного класса --- \code{UDPClient}.\\[3mm]

Набор и формат консольных команд как в клиентской части, так и в серверной полностью совпадают с описанными в разделе \ref{sec:arch:tcp}.

\section{Особенности реализации сетевых и многопоточных приложений}\label{sec:net}
%сетевых и многопоточных приложений: readn, завершение потоков, мьютексы и др

\subsection{Приложение на основе \code{TCP}}

\subsection{Приложение на основе \code{UDP}}

\section{Результаты тестирования}
%приложения (с разным набором входных данных, методика тестирования параллельности обработки запросов клиентов, проверка программы на потерю, дублирование и перемешивание дейтаграмм) .

\section{Выводы}
%Анализ выполненных заданий, сравнение удобства/эффективности/количества проблем при программировании TCP/UDP. Если для реализации прикладного протокола поверх UDP потребовалась модификация прикладного протокола, упомянуть эти измнения. Области применения протоколов TCP и UDP

\end{document}
